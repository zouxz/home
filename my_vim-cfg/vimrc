""""""""""""""""""""""""""""Vundle""""""""""""""""""""""""""""""""""""
let mapleader=','

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Vundle need:
"set rtp+=.vim/bundle/vim-plug/plug.vim
"Plugin 'VundleVim/Vundle.vim'
"call vundle#begin()
"Plugin 'tpope/vim-fugitive'
"call vundle#end()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""



"github上源码路径，即github.com/后的部分
" vim-plug初始化
call plug#begin('~/.vim/pluged')
"Plug 'neoclide/coc.nvim', {'tag': '*', 'do': { -> coc#util#install()}}
""Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }

Plug 'ludovicchabant/vim-gutentags'
Plug 'skywind3000/gutentags_plus'
 " gutentags 搜索工程目录的标志，当前文件路径向上递归直到碰到这些文件/目录名
let g:gutentags_project_root = ['.project']
" 所生成的数据文件的名称
let g:gutentags_ctags_tagfile = '.tags'
" 同时开启 ctags 和 gtags 支持：
let g:gutentags_modules = []

if executable('ctags')
    let g:gutentags_modules += ['ctags']
endif

" exec: gtags and creat G* in  ~/.cache/tags/xxx
if executable('gtags-cscope') && executable('gtags')
    let g:gutentags_modules += ['gtags_cscope']
endif

" 将自动生成的 tags 文件全部放入 ~/.cache/tags 目录中，避免污染工程目录 "
let s:vim_tags = expand('~/.cache/tags')
let g:gutentags_cache_dir = s:vim_tags
" 检测 ~/.cache/tags 不存在就新建 "
if !isdirectory(s:vim_tags)
   silent! call mkdir(s:vim_tags, 'p')
endif

" 配置 ctags 的参数
let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
let g:gutentags_ctags_extra_args += ['--c-kinds=+px']

" 如果使用 universal ctags 需要增加下面一行
let g:gutentags_ctags_extra_args += ['--output-format=e-ctags']

" 禁用 gutentags 自动加载 gtags 数据库的行为
" 避免多个项目数据库相互干扰
" 使用plus插件解决问题
let g:gutentags_auto_add_gtags_cscope = 0

"let g:gutentags_plus_switch = 1
"messege debug
let g:gutentags_define_advanced_commands = 1


 Plug 'skywind3000/vim-preview'
""预览 quickfix 窗口 ctrl-w z 关闭
"P 预览 大p关闭
autocmd FileType qf nnoremap <silent><buffer> p :PreviewQuickfix<cr>
autocmd FileType qf nnoremap <silent><buffer> P :PreviewClose<cr>
noremap <Leader>u :PreviewScroll -1<cr> " 往上滚动预览窗口
noremap <leader>d :PreviewScroll +1<cr> "  往下滚动预览窗口

"" 打开 Quickfix 窗口
let g:Gtags_OpenQuickfixWindow = 1
" 在左边打开窗口，默认为下边打开
let g:Gtags_VerticalWindow =  0
" 启用一些推荐的快捷键，默认不开启
let g:Gtags_Auto_Map = 0
" 保存文件之后自动更新 GTAGS 文件
let g:Gtags_Auto_Update = 0


" Ctrl + p open/close Quickfix and close Prewindow
nnoremap <C-p> :call QuickfixToggle()<cr><Esc><C-w>z
let g:quickfix_is_open = 0
function! QuickfixToggle()
    if g:quickfix_is_open
        cclose
        let g:quickfix_is_open = 0
    else
        copen
        let g:quickfix_is_open = 1
    endif
endfunction
" PreviewSignature
nnoremap <leader>x :PreviewSignature!<cr>


"Load when needed" Plug 'taglist.vim'
Plug '~/.vim/pluged/taglist.vim' , { 'on':  'TlistToggle' }
map tl :TlistToggle<CR>
let Tlist_Use_Right_Window=1
let Tlist_Show_One_File=1
let Tlist_Exit_OnlyWindow=1
let Tlist_WinWidth=28


Plug '~/.vim/pluged/The-NERD-tree', { 'on':  'NERDTreeToggle' }
let NERDTreeWinSize=20
map tr :NERDTreeToggle<CR>

""
""Plug 'scrooloose/nerdcommenter', { 'on': [] }
""augroup load_nerd_com
""	autocmd!
""	autocmd InsertEnter * call plug#load('nerdcommenter') | autocmd! load_nerd_com
""augroup END
""

Plug 'scrooloose/nerdcommenter'

"Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1
" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1
" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'


""Plugin 'indentLine.vim'
""Plugin 'delimitMate.vim'
Plug 'Valloric/YouCompleteMe', { 'on': [] }
augroup load_ycm
	autocmd!
	autocmd InsertEnter * call plug#load('YouCompleteMe') | autocmd! load_ycm
augroup END

let g:ycm_global_ycm_extra_conf = '/home/xizhengzou/.vim/pluged/YouCompleteMe/cpp/.ycm_extra_conf.py'
"打开vim时不再询问是否加载ycm_extra_conf.py配置
"
let g:ycm_confirm_extra_conf = 0
"代码补全
""set completeopt=preview,menu
set completeopt=longest,menu

""自动开启语义补全
let g:ycm_seed_identifiers_with_syntax = 1

"在注释中也开启
let g:ycm_complete_in_comments = 1
let g:ycm_collect_identifiers_from_comments_and_strings = 0

"字符串中也开启补全
let g:ycm_complete_in_strings = 1
let g:ycm_collect_identifiers_from_tags_files = 1

"开启基于tag的补全，可以在这之后添加需要的标签路径
let g:ycm_collect_identifiers_from_tags_files = 1

"开始补全的字符数
let g:ycm_min_num_of_chars_for_completion = 2

"补全后自动关闭预览窗口
let g:ycm_autoclose_preview_window_after_completion = 1

"禁止缓存匹配项,每次都重新生成匹配项
let g:ycm_cache_omnifunc=0

"离开插入模式后自动关闭预览窗口
autocmd InsertLeave * if pumvisible() == 0|pclose|endif

""语法关键字补全
let g:ycm_seed_identifiers_with_syntax = 1

"整合UltiSnips的提示
let g:ycm_use_ultisnips_completer = 1

"在实现和声明之间跳转,并分屏打开
let g:ycm_goto_buffer_command = 'horizontal-split'
nnoremap yd :YcmCompleter GoToDefinition<CR>

""与syntastic有冲突，建议关闭
let g:ycm_show_diagnostics_ui = 0
"let g:ycm_error_symbol = '>>'
"let g:ycm_warning_symbol = '>>'

let g:ycm_enable_diagnostic_signs = 0
let g:ycm_enable_diagnostic_highlighting = 0
let g:ycm_echo_current_diagnostic = 0

"回车选中
inoremap <expr> <CR>  pumvisible() ? "\<C-y>" : "\<CR>"

let g:ycm_semantic_triggers =  {
\   'c' : ['->', '.'],
\   'objc' : ['->', '.', 're!\[[_a-zA-Z]+\w*\s', 're!^\s*[^\W\d]\w*\s',
\             're!\[.*\]\s'],
\   'ocaml' : ['.', '#'],
\   'cpp,objcpp' : ['->', '.', '::'],
\   'perl' : ['->'],
\   'php' : ['->', '::'],
\   'cs,java,javascript,typescript,d,python,perl6,scala,vb,elixir,go' : ['.'],
\   'ruby' : ['.', '::'],
\   'lua' : ['.', ':'],
\   'erlang' : [':'],
\ }


highlight PMenu ctermfg=0 ctermbg=242 guifg=black guibg=darkgrey
highlight PMenuSel ctermfg=242 ctermbg=8 guifg=darkgrey guibg=black

call plug#end()


"将ctags生成的tag改成.tags，这样在项目的子目录中也可以跳转了
set tags=./tags;,tags


filetype plugin indent on

" differently from regular Vi. They are highly recommended though.
"set showcmd            " Show (partial) command in status line.
"set ignorecase         " Do case insensitive matching
"set smartcase          " Do smart case matching
"set incsearch          " Incremental search
"set hidden             " Hide buffers when they are abandoned
set mouse=     " Enable mouse usage (all modes)

""""""""""""""""""""""""""格式""""""""""""""""""""""""""""""""""""""""""
"" Show the cursor position all the time
"" Display incomplete commands
"" Set fileencodings
"set fileencodings=utf-8,bg18030,gbk,big5

"" Display extra whitespace
set list listchars=tab:»·,trail:·
"
"" Make it obvious where 80 characters is
set textwidth=100

"set matchpairs+=<:>


" 设置当文件被改动时自动载入
""set autoread
" quickfix模式
autocmd FileType c,cpp map <buffer> <leader><space> :w<cr>:make<cr>
"允许插件
filetype plugin on
"共享剪贴板
""set clipboard=unnamed
"从不备份
set nobackup
"make 运行
set makeprg=g++\ -Wall\ \ %


"tag next 自动保存
""set autowrite
set ruler                   " 打开状态栏标尺
set cursorline              " 突出显示当前行
set guioptions-=T           " 隐藏工具栏
set guioptions-=m           " 隐藏菜单栏
" 设置在状态行显示的信息
set foldcolumn=0
set foldmethod=indent
set foldlevel=3
set foldenable              " 开始折叠

" 不要使用vi的键盘模式，而是vim自己的
set nocompatible
" 语法高亮
set syntax=on
" 去掉输入错误的提示声音
set noeb
" 在处理未保存或只读文件的时候，弹出确认
set confirm
" 自动缩进
set autoindent
set cindent
" Tab键的宽度
set tabstop=4
" 统一缩进为4
set softtabstop=4
set shiftwidth=4
" 不要用空格代替制表符
set noexpandtab
" 在行和段开始处使用制表符
set smarttab
" 行号
" 历史记录数
set history=1000
"禁止生成临时文件
set nobackup
set noswapfile
"搜索忽略大小写
set ignorecase
"搜索逐字符高亮
set hlsearch
set incsearch
"行内替换
set gdefault
"编码设置
set enc=utf-8
set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936
"语言设置
set langmenu=zh_CN.UTF-8
set helplang=cn



""""""""""""""""""""molokai""""""""""""""""""""""""""""""'
""molakai Color scheme .vim/colors    /usr/share/vim/vim74/colors
""highlight NonText guibg=#060606
""highlight Folded  guibg=#0A0A0A guifg=#9090D0
" 显示颜色
set t_Co=256

"set autochdir
set background=dark
colorscheme molokai_dark
"colorscheme torte
""colorscheme badwolf
""colorscheme jelleybeans

" 总是显示状态行
set laststatus=2
"底部状态栏
set statusline=%F%m%r%h%w\ [%04l,%L]
"hi  StatusLine term=reverse ctermfg=0 ctermbg=7 gui=bold,reverse



""Vim识别三种不同的终端：term，黑白终端；cterm，彩色终端；gui，Gvim窗口。
"ctermfg设置前景色；用ctermbg设置背景色,蓝底红字并使用下划线来显示注释：
"highlight Comment cterm=underline ctermfg=red ctermbg=blue
"gui，可以使用选项gui=attribute，来定义图形窗口下语法元素的显示属性。选项guifg和guibg，
"用来定义了前景色和背景色。推荐使 用的颜色包括：black, brown, grey, blue, green, cyan, magenta, yellow, white。

"The background vi is same as shell
hi Normal  ctermfg=256 ctermbg=none
hi QuickFixLine  term=bold cterm=bold ctermfg=229 gui=bold guifg=#E6DB74
hi Search term=bold cterm=bold ctermfg=256  ctermbg=red
hi Directory  term=bold cterm=bold ctermfg=yellow gui=bold guifg=#A6E22E
hi Visual     term=reverse ctermbg=240: guibg=#403D3D
hi Comment    term=bold ctermfg=68 guifg=#7E8E91

" hide mode
set noshowmode

"顶部显示文件名
set showtabline=2

set cmdheight=2
" 侦测文件类型
filetype on
" 载入文件类型插件
filetype plugin on
" 为特定文件类型载入相关缩进文件
filetype indent on


" 保存全局变量
set viminfo+=!
" 带有如下符号的单词不要被换行分割
set iskeyword+=_,$,@,%,#,-
" 字符间插入的像素行数目
set linespace=0
" 增强模式中的命令行自动完成操作
set wildmenu
" 使回格键（backspace）正常处理indent, eol, start等
set backspace=2
" 允许backspace和光标键跨越行边界
set whichwrap+=<,>,h,l
" 通过使用: commands命令，告诉我们文件的哪一行被改变过
set report=0
" 在被分割的窗口间显示空白，便于阅读
"set fillchars=vert:\ ,stl:\ ,stlnc:\

" Show matching brackets.
set showmatch
" 匹配括号高亮的时间（单位是十分之一秒）
set matchtime=1
" 光标移动到buffer的顶部和底部时保持3行距离
set scrolloff=3
" 为C程序提供自动缩进
set smartindent
" 高亮显示普通txt文件（需要txt.vim脚本）
 au BufRead,BufNewFile *  setfiletype txt

"自动补全口号双引号等
:inoremap ( ()<ESC>i
:inoremap ) <c-r>=ClosePair(')')<CR>
":inoremap { {<CR>}<ESC>O
":inoremap } <c-r>=ClosePair('}')<CR>
:inoremap [ []<ESC>i
:inoremap ] <c-r>=ClosePair(']')<CR>
:inoremap " ""<ESC>i
:inoremap ' ''<ESC>i
function! ClosePair(char)
	if getline('.')[col('.') - 1] == a:char
		return "\<Right>"
	else
		return a:char
	endif
endfunction


filetype plugin indent on

"location
autocmd BufReadPost * if line("'\"")>0&&line("'\"")<=line("$") | exe "normal g'\"" | endif


set timeoutlen=1000 ttimeoutlen=0


"mark  tag
nnoremap 'a `a
nnoremap 'd `d
nnoremap 'b `b

nnoremap <space>p :bp<cr>
""nnoremap <leader>bn :bn<CR>
""nnoremap <leader>bp :bp<CR>


nnoremap  o   o<Esc>


"""""""""""""""""""""":h key-notation
"print debug
map  <leader>\  oi	printf("%s++++%s->x_x  \n", __FILE__, __func__);<Esc>/x_x<cr>ciw

map  <C-\>      oi	printk("%s++++%s->x_x  \n", __FILE__, __func__);<Esc>/x_x<cr>ciw


"nnoremap  <C-\>    <Esc>oprintk("---%s------> x_x  \n",__func__);<Esc>/x_x<cr>ciw
"inoremap  <C-\>    <Esc>oprintk("---%s------> x_x  \n",__func__);<Esc>/x_x<cr>ciw
"nnoremap  <C-a>\   <Esc>oprintf("---%s------> x_x  \n",__func__);<Esc>/x_x<cr>ciw
"inoremap  <C-a>\   <Esc>oprintf("---%s------> x_x  \n",__func__);<Esc>/x_x<cr>ciw


" 窗口切换快捷键
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
inoremap <C-h> <Esc><C-w>h
inoremap <C-j> <Esc><C-w>j
inoremap <C-k> <Esc><C-w>k
inoremap <C-l> <Esc><C-w>l

inoremap <C-e> <Esc>:w<cr>

" 窗口大小调整
nnoremap + :resize +2<cr>
nnoremap _ :resize -2<cr>
nnoremap > :vertical resize +2<cr>
nnoremap < :vertical resize -2<cr>

"Copy to system paste board
vnoremap  <leader>y  "+y
nnoremap  <leader>p  "+p


"set so=7

map <leader>nu  :set nu<cr>
map <leader>nn  :set nonu<cr>


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"let $GTAGSLABEL = 'native-pygments'
"let $GTAGSCONF = '/usr/local/share/gtags/gtags.conf'
"
"set cscopetag " 使用 cscope 作为 tags 命令
"set cscopeprg='gtags-cscope' " 使用 gtags-cscope 代替 cscope
"""gtags.vim 设置项
"let GtagsCscope_Auto_Load = 1
"let CtagsCscope_Auto_Map = 1
"let GtagsCscope_Quiet = 1
""find GTAGS
"let gtags_file=findfile("GTAGS", ";")
"if !empty(gtags_file)
"    exec "cs add" gtags_file
"endif
"
"
"" 向上递归查找tags文件
"let g:filename_tags=findfile("filename.tags", ".;")
"" 设置tags文件
"if filereadable(g:filename_tags)
"    let g:LookupFile_TagExpr='"'.g:filename_tags.'"'
"endif
"


" cscope配置
" -----------------------------------------------------------------------------
" 更新cscope数据库函数
"
"function! UpdateCsdb(path)
"	execute "cd " . a:path
"    call job_start("cscope -bkq")
"	execute "cd -"
"	execute "silent cs reset"
"endfunction
"
"" 更新GTAGS数据库函数
"function! UpdateGtags(f)
"    let g:dir = fnamemodify(a:f, ':p:h')
"    execute "cd " . g:dir
"    call job_start("global -u")
"	execute "cd -"
"endfunction
"


"if executable('cscope')
"    " 获取GTAGS目录
"    let s:gtfile = system('global -pq')
"	" 向上递归寻找cscope.files
"    let s:csfile = findfile("cscope.out", ".;")
"
"	" 如果存在cscope.out则获取目录
"    if filereadable(s:csfile)
"        " 设置cscope模式标志
"        let g:csflag = 0
"        " 获取cscope.out目录
"        let s:pathlen = strridx(s:csfile, "cscope.out")
"		let g:cspath = strpart(s:csfile, 0, s:pathlen)
"	" 如果存在cscope.out则获取目录
"    elseif s:gtfile != ""
"        " 设置cscope模式标志
"        let g:csflag = 1
"        " 获取GTAGS目录
"		let g:gtpath = strpart(s:gtfile, 0, strlen(s:gtfile) - 1)
"    " 使用gutentags_plus
"    else
"        " 设置cscope模式标志
"        let g:csflag = 2
"	endif
"
"    " cscope程序位置
"	if !exists("g:cspath") && executable('gtags-cscope')
"        " 设置cscope映射的程序
"        set csprg=/usr/local/bin/gtags-cscope
"        if g:csflag == 1
"            " 加载GTAGS
"            execute 'silent cs add ' . g:gtpath . '/GTAGS'
"            " 保存文件后自动更新GTAGS
"            autocmd BufWritePost * call UpdateGtags(expand('<afile>'))
"        else
"            execute 'silent GscopeKill'
"        endif
"    else
"        " 设置cscope映射的程序
"        set csprg=/usr/bin/cscope
"        " 自动命令查找结果不使用quickfix窗口
"        " autocmd BufReadPost * set cscopequickfix=""
"        " 保存文件后自动更新GTAGS
"        autocmd BufWritePost * call UpdateCsdb(g:cspath)
"        " 加载cscope.out
"    	set nocsverb
"		execute 'cs add ' . s:csfile
"    endif
"
"    " 显示添加数据库结果
"    set csverb
"    " 使用cstag命令代替tag命令
"    set cst
"    " 优先搜索tags,失败再搜索cscope.out
"    set csto=0
"    " 显示文件路径全名
"    set cspc=0
"endif






"设置disctea的查找结果输出到quick窗口
"set cscopequickfix=s+,c+,d-,i-,t-,e-,a-

"  " 查找忽略大小写
"  function! LookupFile_IgnoreCaseFunc(pattern)
"      let _tags = &tags
"      try
"          let &tags = eval(g:LookupFile_TagExpr)
"          let newpattern = '\c' . a:pattern
"          let tags = taglist(newpattern)
"      catch
"          echohl ErrorMsg | echo "Exception: " . v:exception | echohl NONE
"          return ""
"      finally
"          let &tags = _tags
"      endtry
"
"      " Show the matches for what is typed so far.
"      let files = map(tags, 'v:val["filename"]')
"      return files
"  endfunction
"  let g:LookupFile_LookupFunc = 'LookupFile_IgnoreCaseFunc'


" shell命令调用函数
function! RunShell(Msg, Shell)
	echo a:Msg . '...'
	call system(a:Shell)
	echon 'done'
endfunction
"generate ctags & gtags
nmap <leader>tg :call RunShell("Generate tags","ctags -R --c-kinds=+lpxzL --c++-kinds=+lpxzLANU --fields=+niazS --extras=+q --output-format=e-ctags")<cr>
nmap <leader>gt :call RunShell("Generate GTAGS.*", 'find . -name "*.[chsS]" -o -name "*.cpp" -o -name "*.cc" -o -name "*.C", -o -name "*.cxx"> gtags.files && gtags')<cr>

"nmap <F10> :call RunShell("Generate cscope.*", 'find `pwd` -name "*.[chsS]" -o -name "*.cpp" -o -name "*.cc" -o -name "*.C", -o -name "*.cxx"> cscope.files && cscope -bkq')<cr>


"gtags-cscope跳转快捷键
"    fs： 查找并跳转到当前光标所在标识符出现的地方
"    fg： 查找并跳转到当前光标所在标识符的定义处
"    fd： 查找并跳转到被当前光标所在函数调用的函数
"    fc： 查找并跳转到调用当前光标所在函数的地方
"    ft： 查找并跳转到当前光标所在的字符串
"    fe： egrep模式查找并跳转到当前光标所在的字符串
"    ff： 查找并跳转到当前光标所在的文件名
"    fi： 查找并跳转到当前文件所包含的文件
"    fa： 查找并跳转到当前光标所在的标识符被赋值的地方
nnoremap <Leader>fs :cs find s <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>fg :cs find g <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>fd :cs find d <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>fc :cs find c <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>ft :cs find t <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>fe :cs find e <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>ff :cs find f <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>fi :cs find i <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>fa :cs find a <C-R>=expand("<cword>")<cr><cr>


" gtags-cscope跳转&垂直分割窗口快捷键
nnoremap <Leader>vs :vert scs find s <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vg :vert scs find g <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vd :vert scs find d <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vc :vert scs find c <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vt :vert scs find t <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>ve :vert scs find e <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vf :vert scs find f <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>vi :vert scs find i <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>va :vert scs find a <C-R>=expand("<cword>")<cr><cr>





"如果启用了gutentags_plus插件，查找跳转快捷键不再是原来自定义的三组快捷键了，
"因为gutentags_plus插件本身定义了自己的快捷键，并且使用quickfix窗口来显示查找结果，而且可以按p预览，P关闭预览。
"启用了gutentags_plus插件的快捷键如下：
"gutentags-plus hotkey
noremap <silent> <space>cs :GscopeFind s <C-R><C-W><cr>
noremap <silent> <space>cg :GscopeFind g <C-R><C-W><cr>
noremap <silent> <space>cc :GscopeFind c <C-R><C-W><cr>
noremap <silent> <space>ct :GscopeFind t <C-R><C-W><cr>
noremap <silent> <space>ce :GscopeFind e <C-R><C-W><cr>
noremap <silent> <space>cf :GscopeFind f <C-R>=expand("<cfile>")<cr><cr>
noremap <silent> <space>ci :GscopeFind i <C-R>=expand("<cfile>")<cr><cr>
noremap <silent> <space>cd :GscopeFind d <C-R><C-W><cr>
noremap <silent> <space>ca :GscopeFind a <C-R><C-W><cr>


""""""""""""""""""""""""""焦点"""""""""""""""""""""""""""""""""""""""""
"au WinLeave * set nocursorline nocursorcolumn
"au WinEnter * set cursorline cursorcolumn
"set cursorline cursorcolumn



